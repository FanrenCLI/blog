---
title: gc
date: 2021-12-20 17:26:18
categories:
  - JAVA
tags:
  - GC
author: Fanrencli
---

## JVM 内存模型

![JVM内存模型](http://39.106.34.39:4567/20200101151338500.png)

- 堆：（new）对象存储，数组；
- 方法区：类的加载信息、常量、静态变量、即时编译后的代码；
- 程序计数器：每个线程私有的标记代码的运行位置；
- 虚拟机栈：存储每个方法运行创建的栈帧（局部变量表(对象的引用（对C++中的指针的封装）、基础数据类型)、操作数栈、动态链接、方法出口）；
- 本地方法栈：存储本地方法的服务；

## GC算法

- 标记-清除：先标记，然后清除，但是会导致内存碎片化
- 标记-复制：将内存划分为两块，每次只使用一块，一块使用完后，将清除垃圾后剩下的对象复制到另一块上，然后整体清除此内存块
- 标记-整理：先标记，将活着的对象移动向一端，然后按照边界进行清除
- 分代收集：将内存划分为年轻代和老年代，不同的区域选择不同的算法，一般年轻代选择复制，老年代选择清除或者整理

### 确定垃圾

- 引用计数法：如果一个对象没有一个与之相关的引用，那么他的引用计数都为0，此时可以当作垃圾进行回收
- 可达性分析：通过`GC root`（虚拟机栈中的对象引用、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象）对对象进行分析，如果通过`GC root`可以找到的对象则认为此对象活着，否则作为垃圾；

### 标记过程

- 其中标记分为两次标记：通过GCroot节点第一次的检查可以发现不能到达的对象，然后对这些对象进行第一次标记，在标记过程对这些对象进行检查——是否重写了finalize方法、或者finalize方法是否被调用过，结果分为两种情况：
    - 若重写了finalize方法且这个方法没有被调用过则对这个方法进行调用
    - 若没有重写则不进行调用。
    - 若重写了finalize方法但是之前调用过此方法则不执行。
- 通过第一次标记之后调用finalize方法有的对象可能又被重新引用（逃离死亡），而有的对象则没有逃离，所以在GC发起第二次标记的时候剩下的对象则被清除。其中要注意的是在执行finalize方法时，GC不会等待finalize方法，主要是因为finalize方法可能会长时间执行或假死而导致整个系统的崩溃。

### 标记产生的相关问题解析

在GC过程中要对对象进行标记，在此过程中对象不能再进行更改引用，因此在GC过程中必须要暂停所有线程，但是暂停不能过于频繁，也不能太少，要选择合适的点进行暂停（安全点，这个安全点一般在需要长时间执行的代码处进行标记（for循环、方法调用、异常跳转）），在运行到安全点暂停之后进行GC的检查过程中如果对所有的对象进行遍历检查， 代价过高，hotspot中采用oop数据结构对GCroot节点中的对象引用进行标记，在检查时就可以很快的找到引用对象的位置，因而可以快速确定未被引用的对象位置，但是在代码运行过程中对象的引用是不断变化的，可能运行到这行代码对象引用还是这样，但是下一行代码又产生新的对象引用，这样oop的内容过多，导致一系列的问题，所以在代码运行过程中只在安全点处进行标记——运行到这行代码时，那些对象有引用，那些对象没有引用？。

上面说到要对所有线程进行暂停，但是有的线程执行时，不能立即暂停，需要让它运行到最近的安全点然后暂停，对于所有线程如何暂停——当需要暂停时，JVM生成一个test轮询指令，所有线程对这个指令进行轮询，当线程轮询到这个指令时就暂停。然而还有一个问题，就是在进行GC需要暂停时，在运行的线程可以进行轮询然后暂停，但是若线程此时处于sleep或者blocked状态时，显然它收不到轮询的指令，但是JVM又不知道这个线程什么时候会开始执行，所以为了防止在暂停时由于sleep或blocked状态的线程开始运行而导致对象引用发生变化，JVM设置一个安全域（safeRegion）——在安全域中的线程禁止对象引用发生改变。在线程要离开安全域时检查系统是否完成根节点枚举或者整个GC过程，如果完成则继续运行，反之则等待。

### 垃圾收集算法具体实现（垃圾收集器）

- Serial垃圾收集器（单线程、复制算法）
- Serial Old收集器（单线程标记整理算法 ）
- ParNew垃圾收集器（Serial+多线程）
- Parallel Scavenge收集器（多线程复制算法、高效）
- Parallel Old收集器（多线程标记整理算法）
- CMS收集器（多线程标记清除算法）
- G1收集器





