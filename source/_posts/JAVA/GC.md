---
title: gc
date: 2021-12-20 17:26:18
categories:
  - JAVA
tags:
  - JVM
  - GC
author: Fanrencli
---

## JVM 内存模型

![JVM内存模型](http://39.106.34.39:4567/20200101151338500.png)

- 堆：（new）对象存储，数组（在jdk7后字符串常量、静态变量）；
- 方法区：类的加载信息、常量、即时编译后的代码；
- 程序计数器：每个线程在这里都会私有一个标记代码的运行位置；
- 虚拟机栈：存储每个方法运行创建的栈帧（局部变量表(对象的引用（对C++中的指针的封装）、基础数据类型)、操作数栈、动态链接、方法出口）；
- 本地方法栈：存储本地方法的服务；

## GC算法

- 标记-清除：先标记，然后清除，但是会导致内存碎片化
- 标记-复制：将内存划分为两块，每次只使用一块，一块使用完后，将清除垃圾后剩下的对象复制到另一块上，然后整体清除此内存块
- 标记-整理：先标记，将活着的对象移动向一端，然后按照边界进行清除
- 分代收集：将内存划分为年轻代和老年代，不同的区域选择不同的算法，一般年轻代选择复制，老年代选择清除或者整理

### HotSpot JVM

作为主流的JVM，HotSpot虚拟机采用分代收集的方法，分为老年代和新生代。其中新生代使用标记-复制方法进行垃圾回收，从而将新生代分为Eden和Survivor1和Survivor0三个部分，其中Eden占比较大，如果Eden满了就进行minorGC，将活着的对象放入Survivor中空着的区域，清空Eden和另一个Survivor区域。大对象可能直接进入老年代。
- minorGC：Eden满了会触发minorGC,Survivor满了不会触发，收集整个新生代的垃圾，会触发STW。
- majorGC:收集整个老年代的垃圾，老年代空间不足就会触发
- FullGC：收集整个java堆和方法区的垃圾

![JVM对象分配过程](http://39.106.34.39:4567/jvm_pic1.jpg)

常用的JVM参数设置：
- -XX:+PrintFlagsInitial:查看所有的参数的默认初始值
- -XX:PrintFlagsFinal:查看所有的参数的最终值
- -Xms:初始堆空间大小（默认1/64)
- -Xmx:最大对空间大小（默认1/4）
- -Xmn:设置新生代的大小（初始值及最大值）
- -XX:NewRaito:配置新生代和老年代再对结构的占比
- -XX:SurvivorRatio：设置新生代中的Eden和S0、S1空间的比例
- -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄
- -XX:+PrintGCDetails:输出详细的GC处理日志
- -XX:+PrintGC：打印GC简要信息
- -XX:HandlePromotionFailure:是否设置空间分配担保

对象的分配不一定都在堆上分配，首先通过逃逸分析，如果这个对象只在此方法中使用，则认为没有逃逸，就在栈中分配内存，随着方法销毁。
TLAB的出现是由于堆内空间共享，如果多个线程同时创建对象申请空间就会存在竞争，此时通过给每个线程分配一个TLAB的空间，这样就不需要竞争空间了，TLAB在空间上是私有的，但是内部的对象是共享的。
### 确定垃圾

- 引用计数法：如果一个对象没有一个与之相关的引用，那么他的引用计数都为0，此时可以当作垃圾进行回收
- 可达性分析：通过`GC root`（虚拟机栈中的对象引用、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象）对对象进行分析，如果通过`GC root`可以找到的对象则认为此对象活着，否则作为垃圾；

### 标记过程

- 其中标记分为两次标记：通过GCroot节点第一次的检查可以发现不能到达的对象，然后对这些对象进行第一次标记，在标记过程对这些对象进行检查——是否重写了finalize方法、或者finalize方法是否被调用过，结果分为两种情况：
    - 若重写了finalize方法且这个方法没有被调用过则对这个方法进行调用
    - 若没有重写则不进行调用。
    - 若重写了finalize方法但是之前调用过此方法则不执行。
- 通过第一次标记之后调用finalize方法有的对象可能又被重新引用（逃离死亡），而有的对象则没有逃离，所以在GC发起第二次标记的时候剩下的对象则被清除。其中要注意的是在执行finalize方法时，GC不会等待finalize方法，主要是因为finalize方法可能会长时间执行或假死而导致整个系统的崩溃。

### 标记产生的相关问题解析

在GC过程中要对对象进行标记，在此过程中对象不能再进行更改引用，因此在GC过程中必须要暂停所有线程，但是暂停不能过于频繁，也不能太少，要选择合适的点进行暂停（安全点，这个安全点一般在需要长时间执行的代码处进行标记（for循环、方法调用、异常跳转）），在运行到安全点暂停之后进行GC的检查过程中如果对所有的对象进行遍历检查， 代价过高，hotspot中采用oop数据结构对GCroot节点中的对象引用进行标记，在检查时就可以很快的找到引用对象的位置，因而可以快速确定未被引用的对象位置，但是在代码运行过程中对象的引用是不断变化的，可能运行到这行代码对象引用还是这样，但是下一行代码又产生新的对象引用，这样oop的内容过多，导致一系列的问题，所以在代码运行过程中只在安全点处进行标记——运行到这行代码时，那些对象有引用，那些对象没有引用？。

上面说到要对所有线程进行暂停，但是有的线程执行时，不能立即暂停，需要让它运行到最近的安全点然后暂停，对于所有线程如何暂停——当需要暂停时，JVM生成一个test轮询指令，所有线程对这个指令进行轮询，当线程轮询到这个指令时就暂停。然而还有一个问题，就是在进行GC需要暂停时，在运行的线程可以进行轮询然后暂停，但是若线程此时处于sleep或者blocked状态时，显然它收不到轮询的指令，但是JVM又不知道这个线程什么时候会开始执行，所以为了防止在暂停时由于sleep或blocked状态的线程开始运行而导致对象引用发生变化，JVM设置一个安全域（safeRegion）——在安全域中的线程禁止对象引用发生改变。在线程要离开安全域时检查系统是否完成根节点枚举或者整个GC过程，如果完成则继续运行，反之则等待。

### 垃圾收集算法具体实现（垃圾收集器）

- Serial垃圾收集器（单线程、复制算法）
- Serial Old收集器（单线程标记整理算法）
- ParNew垃圾收集器（Serial+多线程）
- Parallel Scavenge收集器（多线程复制算法、高效）
- Parallel Old收集器（多线程标记整理算法）
- CMS收集器（多线程标记清除算法）
- G1收集器

### 四种引用类型

- 强引用：如果一个对象与GC Roots之间存在强引用，则称这个对象为强可达对象，例如：String asd = new String("");
- 软引用：软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。
```java
  String s = new String("AABB");    // 创建强引用与String对象关联，现在该String对象为强可达状态
  SoftReference<String> softRef = new SoftReference<String>(s);     // 再创建一个软引用关联该对象
  s = null;        // 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态
  s = softRef.get();  // 重新关联上强引用
```
- 弱引用：在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。
```java
  String s = new String("Frank");    
  WeakReference<String> weakRef = new WeakReference<String>(s);
  s = null;

```
- 虚引用：当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。
```java

 private static final ReferenceQueue<Student> QUEUE = new ReferenceQueue<>();
 PhantomReference<Student> phantomReference = new PhantomReference<>(new Student(), QUEUE);
 System.out.println(phantomReference.get());

```

