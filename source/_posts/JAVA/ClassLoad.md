---
title: ClassLoad
date: 2021-12-20 17:19:30
categories:
  - JAVA
tags:
  - Class loader
author: Fanrencli
---

## JVM 类加载机制

- 加载：读取class信息并创建对象， 不一定需要class文件，也可以从jar，war和其他动态生成的代码
- 连接
    - 验证：确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求
    - 准备：在方法区中分配这些变量所使用的内存空间，非final类型初始化默认值，final类型直接赋值；
    - 解析：虚拟机将常量池中的符号引用替换为直接引用的过程
- 初始化：并不是运行`<init>`方法,而是运行类的静态语句块和赋值动作。
    - 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 
    - 定义对象数组，不会触发该类的初始化。 
    - 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
    - 通过类名获取Class对象，不会触发类的初始化。 
    - 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 
    - 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。

## 类加载器

- 启动类加载器：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类
- 扩展类加载器：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
- 应用程序加载器：负责加载用户路径（classpath）上的类库。
- 自定义加载器：用户自定义的加载器

## 双亲委派机制
<p style="text-indent:2em">
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
</p> 
<p style="text-indent:2em">
采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。
</p> 


























